name: Generate Songbook

on:
  schedule:
    # Run every 10 minutes
    - cron: "*/10 * * * *"
  workflow_dispatch:
    inputs:
      force:
        description: "Force regeneration of all songbooks regardless of changes"
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  check-for-updates:
    name: Check for updates
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && !github.event.inputs.force)
    outputs:
      editions_to_build: ${{ steps.check.outputs.editions_to_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Load environment variables
        uses: falti/dotenv-action@v1.1.4
        with: { path: .env, export-variables: true, keys-case: bypass }
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with: { credentials_json: '${{ secrets.GCP_SA_KEY }}' }
      - name: Set up Cloud SDK
        run: gcloud config set project ${{ env.GCP_PROJECT_ID }}
      - name: Check GCS modification times
        id: check
        run: |
          EDITIONS_TO_BUILD='[]'
          SOURCE_PATH="gs://${GCS_WORKER_CACHE_BUCKET}/song-sheets/"

          SOURCE_LATEST_UPDATE_JSON=$(gcloud storage ls "$SOURCE_PATH**" --json | jq -r '.[].updated' | sort -r | head -n 1)
          if [[ -z "$SOURCE_LATEST_UPDATE_JSON" || "$SOURCE_LATEST_UPDATE_JSON" == "null" ]]; then
            echo "No source files found in cache. Nothing to build."
            echo "editions_to_build=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          SOURCE_LATEST_UPDATE_TS=$(date -d "$SOURCE_LATEST_UPDATE_JSON" +%s)
          echo "Latest source file update: $(date -d @$SOURCE_LATEST_UPDATE_TS)"

          for edition in regular complete; do
            DEST_PATH="gs://${GCS_SONGBOOKS_BUCKET}/${edition}.pdf"
            DEST_UPDATE_JSON=$(gcloud storage ls "$DEST_PATH" --json | jq -r '.[].updated' || echo "")
            
            if [[ -z "$DEST_UPDATE_JSON" ]]; then
              echo "Published songbook for '$edition' not found. Adding to build queue."
              EDITIONS_TO_BUILD=$(echo "$EDITIONS_TO_BUILD" | jq ". + [\"$edition\"]")
              continue
            fi
            
            DEST_UPDATE_TS=$(date -d "$DEST_UPDATE_JSON" +%s)
            echo "Latest '$edition' songbook published at: $(date -d @$DEST_UPDATE_TS)"

            if (( SOURCE_LATEST_UPDATE_TS > DEST_UPDATE_TS )); then
              echo "Source files are newer than '$edition' songbook. Adding to build queue."
              EDITIONS_TO_BUILD=$(echo "$EDITIONS_TO_BUILD" | jq ". + [\"$edition\"]")
            else
              echo "Songbook '$edition' is up to date."
            fi
          done

          echo "Editions to build: $EDITIONS_TO_BUILD"
          echo "editions_to_build=$EDITIONS_TO_BUILD" >> $GITHUB_OUTPUT
  
  generate-songbook:
    name: Generate Songbook (${{ matrix.edition }})
    runs-on: ubuntu-latest
    needs: check-for-updates
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.force) ||
      (needs.check-for-updates.outputs.editions_to_build != '[]' && needs.check-for-updates.outputs.editions_to_build != '')
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.force) && fromJson('["regular", "complete"]') || fromJson(needs.check-for-updates.outputs.editions_to_build) }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Load environment variables
      uses: falti/dotenv-action@v1.1.4
      with:
        path: .env
        export-variables: true
        keys-case: bypass

    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      run: gcloud config set project ${{ env.GCP_PROJECT_ID }}
      
    - name: Trigger songbook generation
      run: |
        PAYLOAD=$(jq -n --arg edition "${{ matrix.edition }}" '{ edition: $edition }')
        echo "Triggering songbook generation with payload: $PAYLOAD"
        API_URL="https://${{ env.GCP_REGION }}-${{ env.GCP_PROJECT_ID }}.cloudfunctions.net/${{ env.API_FUNCTION_NAME }}"
        
        RESPONSE=$(curl -s -f -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$API_URL")
        echo "API Response: $RESPONSE"
        JOB_ID=$(echo "$RESPONSE" | jq -r '.job_id')

        if [[ "$JOB_ID" == "null" || -z "$JOB_ID" ]]; then
          echo "Failed to create job"
          exit 1
        fi
        echo "Created job with ID: $JOB_ID"

        TIMEOUT=120
        ELAPSED=0
        POLL_INTERVAL=1

        while [[ $ELAPSED -lt $TIMEOUT ]]; do
          sleep $POLL_INTERVAL
          ELAPSED=$((ELAPSED + POLL_INTERVAL))

          STATUS_RESPONSE=$(curl -s "$API_URL/$JOB_ID")
          STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.status')
          PROGRESS=$(echo "$STATUS_RESPONSE" | jq -r '.progress // 0')
          MESSAGE=$(echo "$STATUS_RESPONSE" | jq -r '.last_message // ""')
          PROGRESS_PERCENT=$(echo "$PROGRESS * 100" | bc -l | awk '{printf "%.0f", $1 + 0.5}')

          echo "[$ELAPSED/${TIMEOUT}s] Status: $STATUS, Progress: ${PROGRESS_PERCENT}%, Message: $MESSAGE"

          if [[ "$STATUS" == "completed" ]]; then
            echo "✅ Songbook generation completed successfully!"
            SOURCE_GCS_PATH="gs://${GCS_CDN_BUCKET}/${JOB_ID}/songbook.pdf"
            DEST_GCS_PATH="gs://${GCS_SONGBOOKS_BUCKET}/${{ matrix.edition }}.pdf"
            echo "Uploading to public bucket: ${DEST_GCS_PATH}"
            gcloud storage cp "${SOURCE_GCS_PATH}" "${DEST_GCS_PATH}"
            echo "✅ Successfully uploaded to ${DEST_GCS_PATH}"
            exit 0
          elif [[ "$STATUS" == "failed" ]]; then
            echo "❌ Songbook generation failed"
            echo "Full response: $STATUS_RESPONSE"
            exit 1
          fi
        done

        echo "⏰ Timeout reached after ${TIMEOUT} seconds"
        exit 1
