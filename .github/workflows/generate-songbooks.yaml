name: Generate Songbook

on:
  schedule:
    # Run every 10 minutes
    - cron: "*/10 * * * *"
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force:
        description: "Force regeneration of all songbooks regardless of changes"
        type: boolean
        default: false

permissions:
  contents: read

env:
  SONGBOOK_EDITIONS: "current complete ukulele-hooley-2025"
  USE_GHOSTSCRIPT_COMPRESSION: false

jobs:
  check-for-updates:
    name: Check for updates
    runs-on: ubuntu-latest
    outputs:
      editions_to_build: ${{ steps.check.outputs.editions_to_build }}
    steps:
      - name: Checkout repository
        id: checkout
        uses: actions/checkout@v4
      - name: Load environment variables
        id: load-env
        uses: falti/dotenv-action@v1.1.4
        with:
          path: .env
          export-variables: true
          keys-case: bypass
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'
      - name: Set up Cloud SDK
        id: setup-sdk
        run: gcloud config set project ${{ env.GCP_PROJECT_ID }}
      - name: Check GCS modification times
        id: check
        run: |
          EDITIONS_TO_BUILD_STR=""

          # Always run change detection logic
          SOURCE_PATH="gs://${GCS_WORKER_CACHE_BUCKET}/song-sheets/"

          GCS_LIST_JSON=$(gcloud storage ls "$SOURCE_PATH**" --json)
          if [[ $? -ne 0 ]]; then
              echo "::warning::'gcloud storage ls' command failed for source path. Assuming cache is empty and building all editions."
              echo "Output was: $GCS_LIST_JSON"
              EDITIONS_TO_BUILD_STR="${{ env.SONGBOOK_EDITIONS }}"
          else
              SOURCE_LATEST_UPDATE_JSON=$(echo "$GCS_LIST_JSON" | jq -r '.[].metadata.updated' | sort -r | head -n 1)
              if [[ -z "$SOURCE_LATEST_UPDATE_JSON" || "$SOURCE_LATEST_UPDATE_JSON" == "null" ]]; then
                echo "No source files found in cache. Nothing to build."
              else
            SOURCE_LATEST_UPDATE_TS=$(date -d "$SOURCE_LATEST_UPDATE_JSON" +%s)
            echo "Latest source file update: $(date -d @$SOURCE_LATEST_UPDATE_TS)"

            for edition in ${{ env.SONGBOOK_EDITIONS }}; do
              FILENAME_PREFIX="ukulele-tuesday-songbook-${edition}"
              DEST_PATH_PREFIX="gs://${GCS_SONGBOOKS_BUCKET}/${FILENAME_PREFIX}"
              GCS_DEST_LIST_JSON=$(gcloud storage ls "${DEST_PATH_PREFIX}*.pdf" --json 2>/dev/null)
              if [[ $? -ne 0 ]]; then
                  echo "No existing songbooks found for edition '${edition}'. Adding to build queue."
                  GCS_DEST_LIST_JSON="[]"
                  EDITIONS_TO_BUILD_STR="${EDITIONS_TO_BUILD_STR} ${edition}"
                  continue
              fi
              LATEST_DEST_UPDATE_JSON=$(echo "$GCS_DEST_LIST_JSON" | jq -r '.[].metadata.updated' | sort -r | head -n 1)

              if [[ -z "$LATEST_DEST_UPDATE_JSON" || "$LATEST_DEST_UPDATE_JSON" == "null" ]]; then
                echo "Published songbook for '$edition' not found. Adding to build queue."
                EDITIONS_TO_BUILD_STR="${EDITIONS_TO_BUILD_STR} ${edition}"
                continue
              fi

              DEST_UPDATE_TS=$(date -d "$LATEST_DEST_UPDATE_JSON" +%s)
              echo "Latest '$edition' songbook published at: $(date -d @$DEST_UPDATE_TS)"

              if (( SOURCE_LATEST_UPDATE_TS > DEST_UPDATE_TS )); then
                echo "Source files are newer than '$edition' songbook. Adding to build queue."
                EDITIONS_TO_BUILD_STR="${EDITIONS_TO_BUILD_STR} ${edition}"
              else
                echo "Songbook '$edition' is up to date."
              fi
            done
          fi
          fi

          # Override result if force mode is enabled or if this is a PR/push
          if [[ ("${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.force }}" == "true") || "${{ github.event_name }}" == "push" || "${{ github.event_name }}" == "pull_request" ]]; then
            echo "Force mode enabled (triggered by: ${{ github.event_name }}). Overriding change detection to build all editions."
            EDITIONS_TO_BUILD_STR="${{ env.SONGBOOK_EDITIONS }}"
          fi

          # Convert the space-separated string to a JSON array for the output
          FINAL_EDITIONS_JSON=$(echo "${EDITIONS_TO_BUILD_STR}" | jq -R 'split(" ") | map(select(length > 0))' | jq -c '.')

          echo "Editions to build: $FINAL_EDITIONS_JSON"
          echo "editions_to_build=$FINAL_EDITIONS_JSON" >> $GITHUB_OUTPUT

  generate-songbook:
    name: Generate Songbook (${{ matrix.edition }})
    runs-on: ubuntu-latest
    needs: check-for-updates
    outputs:
    concurrency:
      group: generate-songbook-${{ matrix.edition }}
      cancel-in-progress: false
    if: needs.check-for-updates.outputs.editions_to_build != '[]' && needs.check-for-updates.outputs.editions_to_build != ''
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ fromJson(needs.check-for-updates.outputs.editions_to_build) }}
    steps:
    - name: Checkout repository
      id: checkout
      uses: actions/checkout@v4

    - name: Load environment variables
      id: load-env
      uses: falti/dotenv-action@v1.1.4
      with:
        path: .env
        export-variables: true
        keys-case: bypass

    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      id: setup-sdk
      run: gcloud config set project ${{ env.GCP_PROJECT_ID }}

    - name: Install uv
      uses: astral-sh/setup-uv@v5

    - name: Trigger and poll for completion
      id: trigger-and-poll
      run: |
        PAYLOAD=$(jq -n --arg edition "${{ matrix.edition }}" '{ edition: $edition }')
        echo "Triggering songbook generation with payload: $PAYLOAD"
        API_URL="https://${{ env.GCP_REGION }}-${{ env.GCP_PROJECT_ID }}.cloudfunctions.net/${{ env.API_FUNCTION_NAME }}"

        RESPONSE=$(curl -s -f -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$API_URL")
        echo "API Response: $RESPONSE"
        JOB_ID=$(echo "$RESPONSE" | jq -r '.job_id')

        if [[ "$JOB_ID" == "null" || -z "$JOB_ID" ]]; then
          echo "Failed to create job"
          exit 1
        fi
        echo "Created job with ID: $JOB_ID"

        TIMEOUT=120
        ELAPSED=0
        POLL_INTERVAL=1
        SOURCE_GCS_PATH=""

        while [[ $ELAPSED -lt $TIMEOUT ]]; do
          sleep $POLL_INTERVAL
          ELAPSED=$((ELAPSED + POLL_INTERVAL))

          STATUS_RESPONSE=$(curl -s "$API_URL/$JOB_ID")
          STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.status')
          PROGRESS=$(echo "$STATUS_RESPONSE" | jq -r '.progress // 0')
          MESSAGE=$(echo "$STATUS_RESPONSE" | jq -r '.last_message // ""')
          PROGRESS_PERCENT=$(echo "$PROGRESS * 100" | bc -l | awk '{printf "%.0f", $1 + 0.5}')

          echo "[$ELAPSED/${TIMEOUT}s] Status: $STATUS, Progress: ${PROGRESS_PERCENT}%, Message: $MESSAGE"

          if [[ "$STATUS" == "completed" ]]; then
            echo "✅ Songbook generation completed successfully!"
            SOURCE_GCS_PATH="gs://${GCS_CDN_BUCKET}/${JOB_ID}/songbook.pdf"
            MANIFEST_GCS_PATH="gs://${GCS_CDN_BUCKET}/${JOB_ID}/manifest.json"
            echo "source_gcs_path=${SOURCE_GCS_PATH}" >> $GITHUB_OUTPUT
            echo "manifest_gcs_path=${MANIFEST_GCS_PATH}" >> $GITHUB_OUTPUT
            break
          elif [[ "$STATUS" == "failed" ]]; then
            echo "❌ Songbook generation failed"
            echo "Full response: $STATUS_RESPONSE"
            exit 1
          fi
        done

        if [[ -z "$SOURCE_GCS_PATH" ]]; then
          echo "⏰ Timeout reached after ${TIMEOUT} seconds"
          exit 1
        fi

    - name: Install Ghostscript
      if: env.USE_GHOSTSCRIPT_COMPRESSION == 'true'
      id: install-ghostscript
      run: |
        sudo apt-get update
        sudo apt-get install -y ghostscript

    - name: Download uncompressed PDF
      if: env.USE_GHOSTSCRIPT_COMPRESSION == 'false'
      run: |
        SOURCE_GCS_PATH="${{ steps.trigger-and-poll.outputs.source_gcs_path }}"
        OUTPUT_PDF="ukulele-tuesday-songbook-${{ matrix.edition }}.pdf"
        echo "Downloading generated PDF from ${SOURCE_GCS_PATH} to ${OUTPUT_PDF}"
        gcloud storage cp "${SOURCE_GCS_PATH}" "${OUTPUT_PDF}"

    - name: Post-process PDF
      if: env.USE_GHOSTSCRIPT_COMPRESSION == 'true'
      id: post-process
      run: |
        SOURCE_GCS_PATH="${{ steps.trigger-and-poll.outputs.source_gcs_path }}"
        INPUT_PDF="uncompressed.pdf"
        OUTPUT_PDF="ukulele-tuesday-songbook-${{ matrix.edition }}.pdf"

        echo "Downloading generated PDF from ${SOURCE_GCS_PATH} to ${INPUT_PDF}"
        gcloud storage cp "${SOURCE_GCS_PATH}" "${INPUT_PDF}"

        echo "Compressing PDF with Ghostscript..."
        gs -sDEVICE=pdfwrite \
          -dCompatibilityLevel=1.4 \
          -dPDFSETTINGS=/default \
          -dSubsetFonts=false \
          -dEmbedAllFonts=true \
          -dDetectDuplicateImages=true \
          -dNOPAUSE -dBATCH \
          -sOutputFile="${OUTPUT_PDF}" \
          "${INPUT_PDF}"

    - name: Download Manifest
      run: |
        MANIFEST_GCS_PATH="${{ steps.trigger-and-poll.outputs.manifest_gcs_path }}"
        MANIFEST_FILE="manifest.json"
        echo "Downloading generation manifest from ${MANIFEST_GCS_PATH} to ${MANIFEST_FILE}"
        gcloud storage cp "${MANIFEST_GCS_PATH}" "${MANIFEST_FILE}"

    - name: Validate Generated PDF
      run: |
        set -e
        OUTPUT_PDF="ukulele-tuesday-songbook-${{ matrix.edition }}.pdf"
        MANIFEST_FILE="manifest.json"

        echo "Validating generated PDF: ${OUTPUT_PDF}"
        echo "Using manifest file: ${MANIFEST_FILE}"

        # Use enhanced validation with manifest
        uv run songbook-tools validate-pdf "${OUTPUT_PDF}" \
          --manifest "${MANIFEST_FILE}" \
          --verbose

        echo "✅ PDF validation passed for ${{ matrix.edition }} edition"

    - name: Upload Songbook Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ukulele-tuesday-songbook-${{ matrix.edition }}
        path: ukulele-tuesday-songbook-${{ matrix.edition }}.pdf

  publish-songbooks:
    name: Publish Songbooks and Manifest
    runs-on: ubuntu-latest
    needs: [check-for-updates, generate-songbook]
    if: github.ref == 'refs/heads/main' && needs.check-for-updates.outputs.editions_to_build != '[]' && needs.check-for-updates.outputs.editions_to_build != ''
    steps:
    - name: Checkout repository
      id: checkout
      uses: actions/checkout@v4
    - name: Load environment variables
      id: load-env
      uses: falti/dotenv-action@v1.1.4
      with:
        path: .env
        export-variables: true
        keys-case: bypass

    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      id: setup-sdk
      run: gcloud config set project ${{ env.GCP_PROJECT_ID }}

    - name: Install uv
      uses: astral-sh/setup-uv@v5

    - name: Download all songbook artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./songbooks
        pattern: ukulele-tuesday-songbook-*
        merge-multiple: true

    - name: Upload PDFs to GCS
      id: upload-pdfs
      run: |
        set -e
        DATE=$(date -u +%Y-%m-%d)
        for pdf_file in ./songbooks/*.pdf; do
          if [ -f "$pdf_file" ]; then
            original_filename=$(basename "$pdf_file")
            # Extract edition from "ukulele-tuesday-songbook-EDITION.pdf"
            edition=$(echo "$original_filename" | sed -e 's/ukulele-tuesday-songbook-\(.*\)\.pdf/\1/')
            new_filename="ukulele-tuesday-songbook-${edition}-${DATE}.pdf"
            dest_gcs_path="gs://${GCS_SONGBOOKS_BUCKET}/${new_filename}"

            echo "Uploading '$original_filename' to '$dest_gcs_path'"
            gcloud storage cp "$pdf_file" "$dest_gcs_path"
          fi
        done

    - name: Generate Manifest
      id: generate-manifest
      run: |
        set -e
        # List all dated PDF files in the bucket to create a comprehensive manifest
        ALL_FILE_PATHS=$(gcloud storage ls "gs://${GCS_SONGBOOKS_BUCKET}/ukulele-tuesday-songbook-*-*.pdf" | tr '\n' ' ')
        if [[ -z "$ALL_FILE_PATHS" ]]; then
          echo "No files found in bucket, skipping manifest creation."
          exit 0
        fi
        MANIFEST_JSON=$(./scripts/generate_manifest.py --file-paths "$ALL_FILE_PATHS")
        echo "Generated Manifest:"
        echo "$MANIFEST_JSON" | jq .
        echo "$MANIFEST_JSON" > manifest.json

    - name: Upload Manifest to GCS
      run: |
        if [ -f "manifest.json" ]; then
          gcloud storage cp manifest.json "gs://${GCS_SONGBOOKS_BUCKET}/manifest.json" --cache-control="public, max-age=60"
          echo "✅ Successfully uploaded manifest.json"
        else
          echo "manifest.json not found, skipping upload."
        fi
